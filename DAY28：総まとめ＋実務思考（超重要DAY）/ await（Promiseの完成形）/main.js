// 🟢 DAY28：総まとめ＋実務思考（超重要DAY）
// 🎯 今日のゴール

// 「何を書けばいいか分からない」状態を卒業

// DOM × 非同期 × 状態管理 が 一本でつながる

// 小さいけど 案件レベルの思考を体験する

// Step1｜実務での基本構造を理解する【15分】

// まず 型 を頭に入れる（これ超重要👇）

// ① DOMを取得
// ② イベントを設定
// ③ 状態 or 入力値を取得
// ④ 非同期処理（必要なら）
// ⑤ 結果をDOMに反映
// 👉 今後どんな課題が来ても、この順番で考える。

// Step2｜ミニ実務課題（超重要）【30分】
// 📌 要件（よくある案件）
// ボタンを押したら

// データを取得中は「読み込み中…」表示

// データ取得成功 → 名前を表示

// 失敗 → エラーメッセージ表示

// 🧠 書く前に考える（←ここが中級）
// 入力は？
// 👉 ボタンクリック

// 状態は？
// 👉 読み込み中 / 完了 / エラー

// 出力は？
// 👉 画面表示（DOM）

// ✅ 正解コード（DAY28完成形）

const btn = document.getElementById("btn");
const result = document.getElementById("result");

btn.addEventListener("click",async() =>{
    result.textContent= "読み込み中...";

    try{
        const result = await fetch("URL");
        const data = await result.json();
        
        result.textContent= `名前：${data.name}`;
    } catch(error){
        result.textContent = "エラー発生";
    }

});


// Step3｜「なぜこう書くか」を文章で説明【15分】

// 見ずに説明できたら 完全合格 👇

// ① なぜ async を使う？

// 非同期処理にしてawaitを使用するためasyncを使用することで分かりやすく記述できる

// ② なぜ「読み込み中…」を先に出す？

// ユーザーが実際に見てわかるように読み込み中を出す。

// ③ try / catch を使う理由は？

// asyncを使用したときは成功のみであればadwait
// 成功失敗を含める場合はtryは成功した時catchは失敗した時のために使用する

// 🟡 意味は合ってる／表現だけ整理しよう

// 正しい整理👇

// await は成功も失敗も起こりうる

// 失敗（エラー）を捕まえるために try / catch を使う

// 通信失敗時でも JS が止まらないようにする

// 👉 考え方は合ってる。
// 👉 言語化はこれからどんどん良くなる。

// ④ このコードで使っている技術は？

// DOM
// 非同期処理(async)
// イベント追加

// 🟢 合格
// もし実務面接だったら、こう言えたらさらに強い👇

// DOM操作

// イベントリスナー

// 非同期処理（fetch / async / await）

// Promise

// エラーハンドリング（try / catch）

// 👉 これ全部、実案件でそのまま使う